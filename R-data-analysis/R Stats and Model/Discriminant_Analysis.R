# 判别分析
# 1.1 判别分析概念
# 判别分析，以判别个体所属群体的一种统计方法。
# 判别分析的假设： 1. 每个判别变量不能是其他判别变量的线性组合，不存在多重共线性的情况。2. 各个判别变量具有多远正态分布
# 2.1 距离判别
# 2.1.1 判别准则和判别函数
# 1. 两个总体协方差相同
# w(x) = (x - mu)^T S^(-1)(mu1-mu2) -- 距离判别函数
# 判别准则： R1 = {x|w(x) >= 0} R2 = {x|w(x) < 0}
# 具体算法里面，就是通过马氏距离的大小来判别
# 2. 两个总体协方差不同
# w(x) = (x - mu1)^T S1^(-1)(x-mu1) - (x - mu2)^T S2^(-1)(x-mu2)-- 距离判别函数
# 判别准则： R1 = {x|w(x) >= 0} R2 = {x|w(x) < 0}
# 具体算法里面，就是通过马氏距离的大小来判别

# > a <- c(1,2,3,4)
# > as.matrix(a)
# [,1]
# [1,]    1
# [2,]    2
# [3,]    3
# [4,]    4
# > t(as.matrix(a))
# [,1] [,2] [,3] [,4]
# [1,]    1    2    3    4

# test data:
classX1<-data.frame(
  x1=c(6.60,  6.60,  6.10,  6.10,  8.40,  7.2,   8.40,  7.50,  
       7.50,  8.30,  7.80,  7.80),
  x2=c(39.00, 39.00, 47.00, 47.00, 32.00,  6.0, 113.00, 52.00,
       52.00,113.00,172.00,172.00),
  x3=c(1.00,  1.00,  1.00,  1.00,  2.00,  1.0,   3.50,  1.00,
       3.50,  0.00,  1.00,  1.50),
  x4=c(6.00,  6.00,  6.00,  6.00,  7.50,  7.0,   6.00,  6.00,
       7.50,  7.50,  3.50,  3.00),
  x5=c(6.00, 12.00,  6.00, 12.00, 19.00, 28.0,  18.00, 12.00,
       6.00, 35.00, 14.00, 15.00),
  x6=c(0.12,  0.12,  0.08,  0.08,  0.35,  0.3,   0.15,  0.16,
       0.16,  0.12,  0.21,  0.21),
  x7=c(20.00, 20.00, 12.00, 12.00, 75.00, 30.0,  75.00, 40.00,
       40.00,180.00, 45.00, 45.00)
)
classX2<-data.frame(
  x1=c(8.40,  8.40,  8.40,  6.3, 7.00,  7.00,  7.00,  8.30,
       8.30,   7.2,   7.2,  7.2, 5.50,  8.40,  8.40,  7.50,
       7.50,  8.30,  8.30, 8.30, 8.30,  7.80,  7.80),
  x2=c(32.0 ,32.00, 32.00, 11.0, 8.00,  8.00,  8.00, 161.00,
       161.0,   6.0,   6.0,  6.0, 6.00,113.00,113.00,  52.00,
       52.00, 97.00, 97.00,89.00,56.00,172.00,283.00),
  x3=c(1.00,  2.00,  2.50,  4.5, 4.50,  6.00,  1.50,  1.50,
       0.50,   3.5,   1.0,  1.0, 2.50,  3.50,  3.50,  1.00,
       1.00,  0.00,  2.50, 0.00, 1.50,  1.00,  1.00),
  x4=c(5.00,  9.00,  4.00,  7.5, 4.50,  7.50,  6.00,  4.00,
       2.50,   4.0,   3.0,  6.0, 3.00,  4.50,  4.50,  6.00,
       7.50,  6.00,  6.00, 6.00, 6.00,  3.50,  4.50),
  x5=c(4.00, 10.00, 10.00,  3.0, 9.00,  4.00,  1.00,  4.00,
       1.00,  12.0,   3.0,  5.0, 7.00,  6.00,  8.00,  6.00,
       8.00,  5.00,  5.00,10.00,13.00,  6.00,  6.00),
  x6=c(0.35,  0.35,  0.35,  0.2, 0.25,  0.25,  0.25,  0.08,
       0.08,  0.30,   0.3,  0.3, 0.18,  0.15,  0.15,  0.16,
       0.16,  0.15,  0.15, 0.16, 0.25,  0.21,  0.18),
  x7=c(75.00, 75.00, 75.00,  15.0, 30.00, 30.00, 30.00, 70.00,
       70.00,  30.0,  30.0,  30.0, 18.00, 75.00, 75.00, 40.00,
       40.00,180.00,180.00,180.00,180.00, 45.00, 45.00)
)

discriminant.dist <- function(x1, x2, test = NULL, var.equal = FALSE){
  if(is.null(test)) test <- rbind(x1, x2)
  if(is.vector(test)){
    test <- t(as.matrix(test)) # 由于as.matrix()将向量转换为矩阵，会导致生成许多样本。需要t来转置，一个向量对应一个样本。
  }else if(is.matrix(test) != TRUE){
    test <- as.matrix(test)
  }
  
  if(is.matrix(x1)) x1 <- as.matrix(x1)
  if(is.matrix(x2)) x2 <- as.matrix(x2)
  
  mu1 <- colMeans(x1)
  mu2 <- colMeans(x2)
  
  nt <- nrow(test) # 表示要测距的向量个数(行数)
  result <- matrix(rep(0, nt), nrow = 1, byrow = TRUE, dimnames = list("result", 1:nt))
  
  if(var.equal){
    S <- cov(rbind(x1, x2))
    compare <- mahalanobis(test, colMeans(tx1), S) - mahalanobis(test, colMeans(tx2), S)
  }else{
    S1 <- cov(x1)
    S2 <- cov(x2)
    compare <- mahalanobis(test, colMeans(tx1), S1) - mahalanobis(test, colMeans(tx2), S2)
  }
  
  for(i in 1:nt){
    if(compare[i] > 0){
      result[i] <- 2
    }else{
      result[i] <- 1
    }
  }
  result
}

# test:
(discriminant.dist(classX1, classX2))

(discriminant.dist(classX1, classX2, var.equal = TRUE))



















