{
    "contents" : "# 多个决策边界进行分类\n\n# Data\nrequire(ggplot2)\nx <- runif(1000, 0, 40)\ny1 <- cbind(runif(100, 0, 10), 1)\ny2 <- cbind(runif(800, 10, 30), 2)\ny3 <- cbind(runif(100, 30, 40), 1)\nvalue <- data.frame(cbind(x, rbind(y1, y2, y3)), stringsAsFactors = TRUE) # 表明字符可转因子\n\n# 用ggplot2画图\nhline <- data.frame(hl = c(10, 30)) # 用于分割geom_hline\nmutil <- ggplot(value, aes(x, V2)) +\n  geom_jitter(aes(shape = as.factor(V3)), height = 2) +\n  scale_shape_discrete(guide = \"none\", solid = FALSE) +\n  geom_hline(aes(yintercept = hl), linetype = 3, hline) +\n  theme_bw() +\n  xlab(\"X\") +\n  ylab(\"Y\")\nmutil\n\n\n# 垃圾邮件分类\nrequire(tm)\n\n# 设置数据路径\nspam.path <- file.path(\"data\", \"spam\")\nspam2.path <- file.path(\"data\", \"spam_2\")\neasyham.path <- file.path(\"data\", \"easy_ham\")\neasyham2.path <- file.path(\"data\", \"easy_ham_2\")\nhardham.path <- file.path(\"data\", \"hard_ham\")\nhardham2.path <- file.path(\"data\", \"hard_ham_2\")\n\n# 读取邮件正文, path 表示文件路径和文件名称 /spam/text.txt, 返回文本向量\nget.msg <- function(path){\n  open_file <- file(path, open = \"rt\", encoding = \"latin1\")\n  mail_text <- readLines(open_file) # 读完文件之后，返回向量化文本，mail_text[1] 表示第一行内容\n  mt_start <- as.numeric(which(mail_text == \"\")[1] + 1)\n  mt_len <- as.numeric(length(mail_text))\n  if(mt_start > mt_len) mt_start = mt_len - 1\n  mail_content <- mail_text[seq(mt_start, mt_len, 1)]\n  close(open_file)\n  return(paste(mail_content, collapse = \"\\n\"))\n}\n\n# 构造词项-文档矩阵 TDM [i,j], 词项i在文档j中出现的次数\nget.tdm <- function(doc.vec){\n  doc.corpus <- Corpus(VectorSource(doc.vec)) # 语料库\n  control <- list(stopwords = TRUE, removePunctuation = TRUE, removeNumbers = TRUE)\n  doc.tdm <- TermDocumentMatrix(doc.corpus, control) #计算词项-文档矩阵 TDM， \n  return(doc.tdm)\n}\n\n# 查询词项出现个数\ncount.word <- function(doc.vec, term){\n  tdm <- get.tdm(doc.vec)\n  word.freq <- rowSums(as.matrix(tdm))\n  term.freq <- word.freq[which(names(word.freq) == term)]\n  return (ifelse(length(term.freq) > 0, term.freq, 0))\n}\n\n# 检验垃圾邮件\nclassify.email <- function(doc.vec, train.df, prior = 0.5, c = 1e-6){\n  tdm <- get.tdm(doc.vec)\n  msg.freq <- rowSums(as.matrix(tdm))\n  msg.match <- intersect(names(msg.freq), train.df$term)\n\n  if(length(msg.match) < 1)\n  {\n    return(prior * c ^ (length(msg.freq)))\n  }\n  else\n  {\n    # 利用贝叶斯定理来求解\n    match.probs <- train.df$occurrence[match(msg.match, train.df$term)]\n    return(prior * prod(match.probs) * c ^ (length(msg.freq) - length(msg.match)))\n  }\n}\n\n\n# 1. Spam 文本向量\nspam.docs <- dir(spam.path)\nspam.docs <- spam.docs[which(spam.docs != \"cmds\")]\nall.spam <- sapply(spam.docs,\n                   function(p) get.msg(file.path(spam.path, p)))\n# 邮件正文提取完毕\nhead(all.spam)\nhtml.spam <- count.word(all.spam, \"html\")\ntable.spam <- count.word(all.spam, \"table\")\nspam.init <- cbind(html.spam, table.spam, \"SPAM\")\n\n# 信息整理\nspam.tdm <- get.tdm(all.spam) # 1. 词项-文档矩阵\nspam.tdm.mat <- as.matrix(spam.tdm) # 2. 矩阵化\nword.freq <- rowSums(spam.tdm.mat) \nspam.df <- data.frame(cbind(names(word.freq), as.numeric(word.freq)), stringsAsFactors = FALSE)\nhead(spam.df)\nnames(spam.df) <- c(\"term\", \"frequency\") # 3. 添加名称\nspam.df$frequency <- as.numeric(spam.df$frequency)\nspam.occurrence <- sapply(1:nrow(spam.tdm.mat),\n                          function(i)\n                          {\n                            length(which(spam.tdm.mat[i, ] > 0)) / ncol(spam.tdm.mat)\n                          })\nhead(spam.occurrence)\nspam.density <- spam.df$frequency/sum(spam.df$frequency)\nspam.df <- transform(spam.df, density = spam.density, occurrence = spam.occurrence)\n\nhead(spam.df[with(spam.df, order(-occurrence)),])\n\n# 2. easyham 文本向量\neasyham.docs <- dir(easyham.path)\neasyham.docs <- easyham.docs[which(easyham.docs != \"cmds\")]\nall.easyham <- sapply(easyham.docs,\n                   function(p) get.msg(file.path(easyham.path, p)))\n# 邮件正文提取完毕\nhead(all.easyham)\nhtml.easyham <- count.word(all.easyham, \"html\")\ntable.easyham <- count.word(all.easyham, \"table\")\neasyham.init <- cbind(html.easyham, table.easyham, \"EASYHAM\")\n# 信息整理\neasyham.tdm <- get.tdm(all.easyham) # 1. 词项-文档矩阵\neasyham.tdm.mat <- as.matrix(easyham.tdm) # 2. 矩阵化\neasyham.word.freq <- rowSums(easyham.tdm.mat) \neasyham.df <- data.frame(cbind(names(easyham.word.freq), as.numeric(easyham.word.freq)), stringsAsFactors = FALSE)\nhead(easyham.df)\nnames(easyham.df) <- c(\"term\", \"frequency\") # 3. 添加名称\neasyham.df$frequency <- as.numeric(easyham.df$frequency)\neasyham.occurrence <- sapply(1:nrow(easyham.tdm.mat),\n                          function(i)\n                          {\n                            length(which(easyham.tdm.mat[i, ] > 0)) / ncol(easyham.tdm.mat)\n                          })\nhead(easyham.occurrence)\neasyham.density <- easyham.df$frequency/sum(easyham.df$frequency)\neasyham.df <- transform(spam.df, density = easyham.density, occurrence = easyham.occurrence)\n\nhead(easyham.df[with(easyham.df, order(-occurrence)),])\n\n\n# 画图\ninit.df <- data.frame(rbind(spam.init, easyham.init),\n                      stringsAsFactors = FALSE)\nnames(init.df) <- c(\"html\", \"table\", \"type\")\ninit.df$html <- as.numeric(init.df$html)\ninit.df$table <- as.numeric(init.df$table)\ninit.df$type <- as.factor(init.df$type)\n\n# 3. 测试\nhardham.docs <- dir(hardham.path)\nhardham.docs <- hardham.docs[which(hardham.docs != \"cmds\")]\nall.hardham <- sapply(hardham.docs,\n                      function(p) get.msg(file.path(hardham.path, p)))\n# 邮件正文提取完毕\nhead(all.hardham)\n\n# use classify function for testing\nhardham.spamtest <- classify.email(all.hardham, train.df = spam.df)\nhardham.easyhamtest <- classify.email(all.hardham, train.df = easyham.df)\n\nhardham.res <- ifelse(hardham.spamtest > hardham.easyhamtest,\n                      TRUE,\n                      FALSE)\nsummary(hardham.res)\n\ndoc.vec <- all.hardham\ntrain.df <- spam.df\nprior <- 0.5\nc <- 0.001\ntdm <- get.tdm(doc.vec)\nmsg.freq <- rowSums(as.matrix(tdm))\nmsg.match <- intersect(names(msg.freq), train.df$term)\n\nif(length(msg.match) > 0){\n  prop <- prior*c^(length(msg.freq))\n}else{\n  # 利用贝叶斯定理来求解\n  match.probs <- train.df$occurrence[match(msg.match, train.df$term)]\n  prop <- prior * prod(match.probs) * c ^ (length(msg.freq) - length(msg.match))\n}\n\nprop\n\nspam.classifier <- function(path)\n{\n  pr.spam <- classify.email(path, spam.df)\n  pr.ham <- classify.email(path, easyham.df)\n  return(c(pr.spam, pr.ham, ifelse(pr.spam > pr.ham, 1, 0)))\n}\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1464658139498.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "700619509",
    "id" : "D8D64C20",
    "lastKnownWriteTime" : 1464685030,
    "path" : "~/GitHub/eledata-data-analysis/R Data Mining/Data Mining Projects/Classification-NaiveBayes-SpamFilter/NavieBayes_SpamFilter.R",
    "project_path" : "R Data Mining/Data Mining Projects/Classification-NaiveBayes-SpamFilter/NavieBayes_SpamFilter.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}